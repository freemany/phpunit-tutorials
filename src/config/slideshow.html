export default [` <!-- page 1 -->
<p>In the coming tutorials, we are going to build some php objects to simulate the real world:</p>
<h5>A Person Push a Cart</h5>
<p>At the same time, you write test cases to test what you have just built for TDD</p>
<p>In my opinion and what I experienced, it is totally up to you to start write a test case first or later after a class/method being built. It is
completely ok and up to your personal taste.</p>
`,


` <!-- page 2 -->
<p>We going to have a Cart, why we have Cart first is because it is an object and dependent on a Person later </p>
<p>However, no mater a cart or a person, they both are a kind of Object in the world, I call it Thing here because
it will be confused to have a object called Object in the codes. So both car and person will extend from this base, Thing</p>
<pre><code class="php">
abstract class Thing
{
    protected $name;

    public function __construct(string $name)
    {
        $this->name = $name;
    }
}
</code></pre>
`,


` <!-- page 3 -->
<p>Now we have a Cart based on Thing</p>
<pre><code class="php">
class Cart extends Thing implements MotionInterface
{
    public function move(): string
    {
        $result = $this->name . ' is moving';
        return $result;
    }
}
</code></pre>
<p>Because a cart can move, so it implements MotionInterface.</p>
<pre><code class="php">
interface MotionInterface
{
    public function move(): string;
}
</code></pre>
<p>Test case for the method 'move'</p>
<pre><code class="php">
class CartTest extends TestCase
{
     public function testMove()
     {
         $name = 'foo';
         $expected = $name . ' is moving';
         $cart = new Cart($name);

         // you can use assertEquals here too, assertSame has type check as well and you need it for array comparision
         $this->assertSame($expected, $cart->move());
     }
}
</code></pre>
<p>Then we run:</p>
<pre><code class="bash">
$ php vendor/bin/phpunit
PHPUnit 7.5.7 by Sebastian Bergmann and contributors.

.                                                                   1 / 1 (100%)

Time: 70 ms, Memory: 4.00 MB

<span class="bg-green">OK (1 test, 1 assertion)</span>
</code></pre>
`,



` <!-- page 4 -->
<h5>Lets have a Person class now</h5>
<pre><code class="php">
class Person extends Thing implements ActionInterface
{
    /**
     * @param Thing $object
     *
     * @return null|string
     */
    public function push(Thing $object): ?string
    {
        if ($object instanceof MotionInterface) {

            return $object->move();
        }

        return null;
    }
}
</code></pre>
<p>A person can action, so the Person implements ActionInterface</p>
<pre><code class="php">
interface ActionInterface
{
    public function push(Thing $object): ?string;
}
</code></pre>`
,

`
<p>Lets write the test for person to test the push method</p>
<pre><code class="php">
   /**
    * @group person
    */
    public function testPushWithMockBuilder()
    {
        $expected = 'expected' . rand();

        $cart = $this->getMockBuilder(Cart::class)
                     ->disableOriginalConstructor()
                     ->getMock();
        $cart->expects($this->once())
             ->method('move')
             ->willReturn($expected);

        $person = new Person('foo');

        $this->assertSame($expected, $person->push($cart));
    }
</code></pre>
<p>First we have a expected value, a random string:</p>
<pre><code class="php">
$expected = 'expected' . rand();
</code></pre>
<p>We just use mock builder to build a mock class</p>
<pre><code class="php">
$cart = $this->getMockBuilder(Cart::class)
             ->disableOriginalConstructor()
             ->getMock();
</code></pre>
<p>To mock it up by forcing return value in method 'move', add assertion with expectation the method should be called once</p>
<pre><code class="php">
$cart->expects($this->once())
     ->method('move')
     ->willReturn($expected);
</code></pre>
<p>Finally we assert the return value from Person::push to be the same as the expected</p>
<pre><code>
$this->assertSame($expected, $person->push($cart));
</code></pre>
`,` <!-- page 4 -->
<p>Instead of using mocker, we can have manually built mock class which can achieve the same result, we put this mock class
in the tests asset</p>
<pre><code class="php">
namespace App\Test\TestAsset;

use App\Thing\Cart;

class CartMock extends Cart
{
    protected $result;

    public function setResult($result): void
    {
        $this->result = $result;
    }

    public function move(): string
    {
        return $this->result;
     }
}
</code></pre>
<p>In the CartMock, we overwrite the move method and force to return a value set by setResult method which is only in the CartMock.</p>
<p>Here is the test:</p>
<pre><code class="php">
/**
 * @group person
 */
public function testPushWithMock()
{
    $expected = 'expected' . rand();

    $cart = new CartMock('bar');
    $cart->setResult($expected);

    $person = new Person('foo');

    $this->assertSame($expected, $person->push($cart));
}
</code></pre>
<p class="text-primary">Horay !!! It works the same way as mocker plus we will have more control in mocking up object/class. Personally I find it cleaner with the black
    magic from Mocker.</p>
`];